# 100 Jours de Développement JavaScript

## Voie d'apprentissage

Jour 1 : Introduction à JavaScript et à l'écosystème du développement web

- Mise en place d'un environnement de développement
- Comprendre le rôle de JavaScript dans le développement Web
- Syntaxe de base et types de données en JavaScript

Jour 2 : Variables et structures de contrôle JavaScript

- Déclarer et affecter des variables
- Utilisation des structures de contrôle (`if-else`, les boucles `for`, les boucles `while`)
- Techniques de débogage en JavaScript

Jour 3 : Fonctions en JavaScript

- Comprendre le rôle des fonctions en JavaScript
- Créer et appeler des fonctions
- Portée et clôture en JavaScript

Jour 4 : Tableaux et objets en JavaScript

- Travailler avec des tableaux en JavaScript
- Accéder aux éléments d'un tableau et les manipuler
- Comprendre les objets en JavaScript
- Introduction à JSON

Jour 5 : Le DOM et la manipulation du DOM

- Introduction au Document Object Model (DOM)
- Manipulation d'éléments HTML en JavaScript
- Gestion des événements en JavaScript

Jour 6 : Travailler avec les API

- Comprendre les API et leur fonctionnement
- Effectuer des requêtes HTTP en JavaScript à l'aide de fetch()
- Analyser et manipuler les données des réponses API

Jour 7 : Programmation asynchrone

- Comprendre la programmation asynchrone en JavaScript
- Utiliser les promesses et async/await pour gérer le code asynchrone

Jour 8 : la POO en JavaScript

- Introduction à la programmation orientée objet (POO) en JavaScript
- Création de classes et d'objets en JavaScript
- Héritage en JavaScript

Jour 9 : Modules et exportations

- Comprendre les modules et les exportations en JavaScript
- Créer et importer des modules en JavaScript

Jour 10 : Manipulation avancée du DOM

- Travailler avec l'arbre DOM et parcourir les éléments
- Créer et manipuler des éléments de façon dynamique
- Gestion avancée des événements en JavaScript

Jour 11 : Stockage web

- Comprendre le stockage web en JavaScript
- Utiliser le stockage local et le stockage de session pour stocker des données

Jour 12 : Validation de formulaire

- Valider la saisie d'un formulaire en utilisant JavaScript
- Créer des messages d'erreur personnalisés et gérer les envois de formulaires

Jour 13 : Expressions régulières

- Comprendre les expressions régulières en JavaScript
- Utiliser les expressions régulières pour valider les entrées et manipuler les chaînes de caractères

Jour 14 : Travailler avec des dates et des heures

- Comprendre l'objet `Date` en JavaScript
- Manipuler les dates et les heures en JavaScript

Jour 15 : Introduction à React

- Comprendre le concept de DOM virtuel
- Mettre en place un projet React
- Comprendre la structure de base d'une application React

Jour 16 : Composants et props dans React

- Comprendre les composants dans React
- Créer et produire le rendu des composants
- Utiliser les props pour passer des données entre les composants

Jour 17 : État et méthodes de cycle de vie en React

- Comprendre l'état en React
- Utiliser les méthodes de cycle de vie en React
- Mettre à jour l'état et rendre les composants

Jour 18 : Gérer les événements en React

- Comprendre les événements en React
- Utiliser les gestionnaires d'événements et les liaisons en React

Jour 19 : Routage en React

- Comprendre le routage en React
- Configurer des routes et naviguer entre elles

Jour 20 : Travailler avec les APIs en React

- Faire des requêtes HTTP en React
- Analyser et manipuler les données des réponses API

Jour 21 : Introduction à Redux

- Comprendre le concept de gestion d'un état global
- Mettre en place un projet Redux
- Comprendre la structure de base d'une application Redux

Jour 22 : Actions et réducteurs en Redux

- Comprendre les actions et les réducteurs dans Redux
- Créer et distribuer des actions
- Gérer les actions dans les réducteurs

Jour 23 : Connecter React et Redux

- Intégrer React et Redux
- Utiliser la bibliothèque react-redux pour connecter des composants au magasin Redux

Jour 24 : Concepts avancés de Redux

- Comprendre le middleware dans Redux
- Travailler avec des actions asynchrones dans Redux

Jour 25 : Création et déploiement d'une application React-Redux

- Créer et empaqueter une application React-Redux pour la production
- Déploiement de l'application sur une plateforme d'hébergement 
    - Netlify, Vercel et les plateformes d'hébergement web, par exemple Hostinger

Jour 26 : Introduction à la programmation côté serveur avec Node.js

- Configuration d'un environnement de développement Node.js
- Comprendre les bases de la programmation côté serveur avec Node.js

Jour 27 : Express.js

- Comprendre le rôle d'Express.js dans la création de serveurs web
- Configurer un serveur Express.js et gérer les requêtes HTTP

Jour 28 : Travailler avec MongoDB

- Comprendre les bases de données NoSQL et le rôle de MongoDB
- Configurer une base de données MongoDB et la connecter à un serveur Node.js

Jour 29 : Mongoose

- Comprendre le rôle de Mongoose dans MongoDB
- Configurer un schéma et un modèle Mongoose
- Interroger une base de données MongoDB avec Mongoose

Jour 30 : Authentification et autorisation des utilisateurs

- Comprendre le concept d'authentification et d'autorisation
- Configuration de l'enregistrement des utilisateurs et des routes de connexion
- Implémentation du hachage de mot de passe et des jetons JWT

Jour 31 : Téléchargement de fichiers et traitement d'images

- Comprendre le concept de téléchargement de fichiers et de traitement d'images
- Configurer les routes de téléchargement de fichiers et gérer le multipart/form-data.
- Utiliser la bibliothèque Sharp pour traiter et redimensionner les images.

Jour 32 : Travailler avec Socket.io

- Comprendre le concept de communication en temps réel avec Socket.io
- Configurer un serveur Socket.io et connecter des clients
- Implémenter des fonctions de chat et de messagerie en temps réel

Jour 33 : Test et débogage des applications Node.js

- Comprendre l'importance des tests et du débogage
- Mise en place d'un environnement de test avec Mocha et Chai
- Déboguer les applications Node.js avec le débogueur et le logging

Jour 34 : Travailler avec des promesses

- Comprendre le concept des promesses en JavaScript
- Créer et enchaîner des promesses
- Utiliser async/await avec les Promesses

Jour 35 : Travailler avec des flux

- Comprendre le concept des flux en Node.js
- Travailler avec des flux lisibles et inscriptibles
- Piping des streams et gestion des erreurs

Jour 36 : MongoDB avancé

- Comprendre les concepts avancés de MongoDB tels que l'agrégation et l'indexation.
- Utiliser le Cadre d'Agrégation MongoDB
- Configurer des index pour améliorer les performances des requêtes

Jour 37 : Express.js avancé

- Comprendre les concepts avancés d'Express.js tels que le middleware et le routage
- Configurer un intergiciel personnalisé dans Express.js
- Organiser les routes et gérer les erreurs

Jour 38 : Introduction à GraphQL

- Comprendre le concept de GraphQL et ses avantages par rapport à REST
- Configurer un serveur GraphQL avec Apollo Server
- Comprendre la structure de base d'un schéma GraphQL

Jour 39 : Requêtes et mutations en GraphQL

- Comprendre le concept de requêtes et de mutations en GraphQL
- Créer et exécuter des requêtes et des mutations
- Gérer les erreurs en GraphQL

Jour 40 : Résolveurs GraphQL

- Comprendre le rôle des résolveurs en GraphQL
- Créer et implémenter des résolveurs
- Gérer la logique asynchrone dans les résolveurs

Jour 41 : Abonnements GraphQL

- Comprendre le concept des abonnements GraphQL
- Configurer un serveur d'abonnements GraphQL
- Implémenter des mises à jour en temps réel avec les abonnements

Jour 42 : Authentification et autorisation en GraphQL

- Comprendre le concept d'authentification et d'autorisation en GraphQL
- Implémentation de l'authentification basée sur JWT dans GraphQL
- Gérer les autorisations et les permissions en GraphQL

Jour 43 : Concepts GraphQL avancés

- Comprendre les concepts GraphQL avancés tels que les directives et les scalaires personnalisés.
- Implémentation de directives personnalisées dans GraphQL
- Création de types de scalaires personnalisés dans GraphQL

Jour 44 : Test et débogage des applications GraphQL (suite)

- Déboguer les applications GraphQL avec le GraphQL Playground et le logging
- Implémenter des tests unitaires et d'intégration pour les résolveurs et le serveur GraphQL

Jour 45 : Mise en cache en GraphQL

- Comprendre le concept de mise en cache en GraphQL
- Implémentation de la mise en cache en mémoire avec Apollo Server
- Déboguer une couche de mise en cache telle que Redis pour GraphQL

Jour 46 : Optimisation des performances en GraphQL

- Comprendre l'importance de l'optimisation des performances en GraphQL
- Mise en œuvre de techniques telles que le batching et le dataLoader pour améliorer les performances
Surveillance et analyse des performances de GraphQL avec des outils comme Apollo Engine

Jour 47 : Déploiement de serveurs GraphQL

- Comprendre le processus de déploiement des serveurs GraphQL
- Configuration d'un environnement de production et déploiement sur une plateforme cloud telle que AWS ou Heroku
- Mise en œuvre de mesures de sécurité telles que SSL et la limitation du débit.

Jour 48 : Introduction à Next.js

- Comprendre le concept d'applications React rendues par le serveur avec Next.js
- Configuration d'un projet Next.js et structure de base d'une application Next.js
- Routage et rendu côté serveur avec Next.js

Jour 49 : Récupération de données avec Next.js

- Comprendre les options de récupération de données en Next.js
- Implémenter la récupération de données côté serveur avec getInitialProps
- Récupérer des données côté client avec useEffect

Jour 50 : Déploiement des applications Next.js

- Comprendre le processus de déploiement des applications Next.js
- Mise en place d'un environnement de production et déploiement sur une plateforme Cloud telle que AWS ou Heroku
- Optimiser le processus de construction et les performances d'une application Next.js

Jour 51 : Async/await et Promesses en profondeur

- Comprendre le concept d'async/await et de Promises en profondeur
- Créer et enchaîner des Promesses
- Déboguer async/await avec les Promesses
- Implémenter la gestion des erreurs avec try/catch et Promise.reject()

Jour 52 : Méthodes avancées de tableaux

- Comprendre les méthodes de tableau avancées telles que map, reduce et filter
- Déboguer ces méthodes pour manipuler et transformer des tableaux
- Implémenter des fonctions d'ordre supérieur personnalisées

Jour 53 : Méthodes objet avancées

- Comprendre les méthodes objet avancées telles que Object.keys, Object.values et Object.entries
- Déboguer ces méthodes pour manipuler et transformer des objets
- Implémenter des fonctions d'ordre supérieur personnalisées

Jour 54 : Fermetures et le modèle de module

- Comprendre le concept des fermetures en JavaScript
- Implémenter le pattern module pour créer des variables et des méthodes privées

Jour 55 : Travailler avec le système de fichiers dans Node.js

- Comprendre le concept de système de fichiers dans Node.js
Lire et écrire dans le système de fichiers
Travailler avec les répertoires et les chemins

Jour 56 : Introduction à TypeScript

- Comprendre le concept de vérification statique des types avec TypeScript
- Mise en place d'un projet TypeScript et configuration des options du compilateur
- Comprendre les types de base en TypeScript

Jour 57 : Interfaces et classes en TypeScript

- Comprendre le concept d'interfaces et de classes en TypeScript
- Créer et implémenter des interfaces
- Extension et implémentation des classes

Jour 58 : Génériques en TypeScript

- Comprendre le concept des génériques en TypeScript
- Création et utilisation de fonctions, classes et interfaces génériques

Jour 59 : Les décorateurs en TypeScript

- Comprendre le concept des décorateurs en TypeScript
- Création et utilisation de décorateurs personnalisés
- Implémentation de modèles de décorateurs avancés

Jour 60 : TypeScript avec React

- Comprendre l'intégration de TypeScript avec React
- Configurer un projet TypeScript React
- Définir des types de prop avec des interfaces et vérifier les types avec TypeScript

Jour 61 : TypeScript avec Node.js

- Comprendre l'intégration de TypeScript avec Node.js
- Configuration d'un projet TypeScript Node.js
- Définir et utiliser les interfaces pour les routes Express.js

Jour 62 : TypeScript avec GraphQL

- Comprendre l'intégration de TypeScript avec GraphQL
- Mise en place d'un projet TypeScript GraphQL
- Définir les types GraphQL et les résolveurs avec TypeScript

Jour 63 : TypeScript avec Next.js

- Comprendre l'intégration de TypeScript avec Next.js
- Configuration d'un projet TypeScript Next.js
- Définition des types pour getInitialProps et le contexte Next.js

Jour 64 : Concepts TypeScript avancés

- Comprendre les concepts TypeScript avancés tels que les enums et les gardes de type
- Déboguer les enums pour définir un ensemble de constantes nommées
- Implémentation des gardes de type pour restreindre le type d'un objet

Jour 65 : Meilleures pratiques pour l'utilisation de TypeScript

- Comprendre les meilleures pratiques d'utilisation de TypeScript dans les grands projets
- Mise en œuvre d'une convention de dénomination et d'un style de code cohérents
- Outils de débogage tels que TSLint et Prettier pour faire respecter les normes de code

Jour 66 : Introduction aux abonnements GraphQL avec Apollo

- Comprendre le concept des abonnements GraphQL avec Apollo
- Configuration d'un serveur d'abonnements GraphQL avec le serveur Apollo
- Implémentation de mises à jour en temps réel avec les abonnements Apollo

Jour 67 : Travailler avec les types scalaires GraphQL

- Comprendre le concept des types scalaires dans GraphQL
- Implémenter des types scalaires personnalisés dans un schéma GraphQL
- Déboguer les types scalaires pour la validation d'entrée et la coercition

Jour 68 : Travailler avec les directives GraphQL

- Comprendre le concept des directives en GraphQL
- Implémenter des directives personnalisées dans un schéma GraphQL
- Déboguer les directives pour la validation et la transformation des entrées

Jour 69 : Optimisation des performances GraphQL

- Comprendre l'importance de l'optimisation des performances en GraphQL
- Implémentation de techniques telles que le batching et le dataLoader pour améliorer les performances
Surveillance et analyse des performances de GraphQL avec des outils tels que Apollo Engine

Jour 70 : Gestion des erreurs GraphQL

- Comprendre l'importance de la gestion des erreurs dans GraphQL
- Implémentation de la gestion personnalisée des erreurs dans un schéma GraphQL
- Gestion des erreurs dans les résolveurs GraphQL

Jour 71 : Meilleures pratiques GraphQL

- Comprendre les meilleures pratiques de création et de maintenance des API GraphQL
- Mise en œuvre d'une convention de dénomination et d'un style de code cohérents
- Outils de débogage tels que GraphQL Code Generator et GraphQL Inspector pour améliorer le processus de développement

Jour 72 : Introduction aux hooks React

- Comprendre le concept des hooks React
- Déboguer les hooks de base comme useState et useEffect
- Implémentation de hooks personnalisés

Jour 73 : Hooks React avancés

- Comprendre les hooks Reacts avancés tels que useContext et useReducer
- Implémenter une logique complexe avec les hooks useMemo et useCallback
- Travailler avec des données asynchrones et le hook useAsync

Jour 74 : Optimisation des performances de React

- Comprendre l'importance de l'optimisation des performances en React
- Implémenter des techniques telles que shouldComponentUpdate et la mémorisation pour améliorer les performances.
- Déboguer le React Profiler pour analyser et optimiser les performances d'une application React.

Jour 75 : Les meilleures pratiques de React

- Comprendre les meilleures pratiques pour construire et maintenir des applications React
- Mise en œuvre d'un style de code et d'une convention de dénomination cohérents.
- Outils de débogage tels que ESLint et Prettier pour faire respecter les normes de code

Jour 76 : Introduction à l'informatique sans serveur avec AWS Lambda

- Comprendre le concept de l'informatique sans serveur avec AWS Lambda
- Configuration d'un compte AWS et création d'une fonction Lambda
- Comprendre la structure de base et l'exécution d'une fonction Lambda.

Jour 77 : Travailler avec les services AWS

- Comprendre le rôle des services AWS dans l'informatique sans serveur.
Connecter une fonction Lambda à d'autres services AWS tels que S3 et DynamoDB
- Déboguer le SDK AWS pour interagir avec les services AWS à partir d'une fonction Lambda.

Jour 78 : Modèles d'architecture sans serveur

- Comprendre les modèles communs pour construire des architectures sans serveur.
- Mise en œuvre d'une architecture pilotée par les événements avec les fonctions Lambda et les événements AWS
- Construire une architecture de microservices avec des fonctions Lambda et API Gateway

Jour 79 : Déploiement et gestion sans serveur

- Comprendre le processus de déploiement et de gestion des applications sans serveur.
- Mise en place d'un pipeline de livraison continue avec AWS CodePipeline et CodeBuild
- Surveillance et débogage des applications sans serveur avec AWS CloudWatch et X-Ray.

Jour 80 : Meilleures pratiques pour les applications sans serveur

- Comprendre les meilleures pratiques pour la création et la maintenance des applications sans serveur.
- Mise en œuvre d'une convention de dénomination et d'un style de code cohérents.
- Outils de débogage tels que Serverless Framework et AWS SAM pour améliorer le processus de développement.

Jour 81 : Itération asynchrone et générateurs

- Comprendre le concept d'itération asynchrone en JavaScript
- Implémentation d'itérateurs et de générateurs asynchrones
- Déboguer les générateurs asynchrones pour traiter de grands ensembles de données

Jour 82 : Expressions régulières avancées

- Comprendre les concepts d'expressions régulières avancées tels que les lookaheads et les backreferences.
- Déboguer ces concepts pour créer des expressions régulières complexes
- Implémentation de fonctions d'expressions régulières personnalisées

Jour 83 : Manipulation avancée du DOM

- Comprendre les techniques de manipulation avancée du DOM telles que les templates littéraux et le shadow DOM
- Déboguer les templates littéraux pour créer du HTML dynamique
- Implémenter le shadow DOM pour encapsuler les styles et les composants

Jour 84 : Web workers

- Comprendre le concept des Web workers et leur rôle dans le développement web
- Configurer un Web worker et communiquer avec lui en utilisant postMessage
- Implémenter les web workers pour améliorer les performances des applications JavaScript

Jour 85 : Service workers

- Comprendre le concept de service worker et son rôle dans le développement Web
- Configuration d'un service worker et utilisation de celui-ci pour mettre en cache des ressources et activer la fonctionnalité hors ligne
- Implémentation de service workers pour améliorer les performances et l'expérience utilisateur des applications web.

Jour 86 : WebRTC

- Comprendre le concept de WebRTC et son rôle dans la communication en temps réel
- Configurer une connexion WebRTC et envoyer des données entre clients
- Implémentation de WebRTC pour la communication vidéo et audio

Jour 87 : WebSockets

- Comprendre le concept des WebSockets et leur rôle dans la communication en temps réel
- Configurer une connexion WebSocket et envoyer des données entre clients
- Implémentation de WebSockets pour le chat et la messagerie en temps réel

Jour 88 : Concepts HTTP avancés

- Comprendre les concepts HTTP avancés tels que les en-têtes et les codes d'état
- Définir et manipuler les en-têtes dans les requêtes et les réponses HTTP
- Implémenter des codes d'état HTTP personnalisés

Jour 89 : Concepts avancés de sécurité Web

- Comprendre les concepts avancés de sécurité web tels que CORS et CSRF
- Mettre en œuvre des mesures de sécurité pour empêcher les attaques d'origine croisée
- Se protéger contre les attaques CSRF à l'aide de tokens

Jour 90 : Optimisation avancée des performances web

- Comprendre les techniques avancées d'optimisation des performances du Web, telles que le fractionnement du code et le tree shaking.
- Mise en œuvre de la division du code avec import() dynamique
- Outils de débogage tels que webpack pour optimiser la taille des bundles des applications Web

Jour 91 : Introduction au registre npm

- Comprendre le concept du registre npm et son fonctionnement
- Configuration d'un compte npm et publication d'un paquet dans le registre
Installation et utilisation des paquets du registre

Jour 92 : Construction d'une plateforme de traitement d'images sans serveur avec AWS Lambda et AWS S3

- Comprendre le concept de construction d'une plateforme de traitement d'images sans serveur avec AWS Lambda et AWS S3.
- Configuration d'un compte AWS et création d'une fonction Lambda
- Connexion d'une fonction Lambda à AWS S3 et mise en œuvre de tâches de traitement d'images.

Jour 93 : Création d'un environnement de ligne de commande avec Node.js

- Comprendre le concept de construction d'un outil de ligne de commande avec Node.js
- Configuration d'un projet Node.js avec une interface de ligne de commande
- Analyser les arguments et les options de la ligne de commande

Jour 94 : Création d'une API REST avec Node.js

- Comprendre le concept de construction d'une API REST avec Node.js
- Configurer un serveur Node.js avec Express.js
- Implémentation de routes CRUD et traitement des requêtes HTTP

Jour 95 : Création d'une API GraphQL avec Node.js

- Comprendre le concept de création d'une API GraphQL avec Node.js
- Configurer un serveur GraphQL avec Apollo Server
- Implémentation d'un schéma et de résolveurs GraphQL

Jour 96 - a : Construire une application de chat en temps réel avec Node.js, AWS Lambda et WebSockets

- Comprendre le concept de la construction d'une application de chat en temps réel avec Node.js
- Configurer un serveur Node.js avec Socket.io
- Implémenter une interface de chat et gérer les messages en temps réel
- Comprendre le concept de la construction d'une application de chat en temps réel sans serveur avec AWS Lambda et WebSockets.
- Configuration d'un compte AWS et création d'une fonction Lambda
- Connexion d'une fonction Lambda à une API WebSocket et mise en œuvre d'une interface de chat.

Jour 97 : Créer une application React rendue par le serveur avec Next.js et GraphQL

- Comprendre le concept de création d'une application React rendue par le serveur avec Next.js et GraphQL
- Configurer un projet Next.js avec Apollo Client
- Récupérer les données d'une API GraphQL avec Next.js

Jour 98 : Création d'un éditeur de document collaboratif en temps réel sans serveur avec AWS Lambda et AWS AppSync

- Comprendre le concept de création d'un éditeur de documents collaboratif en temps réel sans serveur avec AWS Lambda et AWS AppSync.
- Configuration d'un compte AWS et création d'une API AppSync
- Connexion d'une fonction Lambda à AppSync et mise en œuvre d'une interface d'édition collaborative.

Jour 99 : Construction d'une architecture de microservices sans serveur avec AWS Lambda et API Gateway

- Comprendre le concept de construction d'une architecture de microservices sans serveur avec AWS Lambda et API Gateway.
- Connexion des fonctions Lambda à API Gateway et création d'une API REST.

Jour 100 : Création d'une plateforme de e-commerce sans serveur avec AWS Lambda et Stripe

- Comprendre le concept de la création d'une plateforme de commerce électronique sans serveur avec AWS Lambda et Stripe.
- Connexion d'une fonction Lambda à l'API Stripe et mise en œuvre du traitement des paiements.